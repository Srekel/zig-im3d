// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

pub const Im3d = struct {
    pub const U32 = c_uint;

    pub const Id = U32;

    extern const _1_Im3d_Id_Invalid_: *const Id;
    pub const Id_Invalid = _1_Im3d_Id_Invalid_;

    extern fn _1_Im3d_GetAppData_() *AppData;
    /// Get AppData struct from the current context, fill before calling NewFrame().
    pub const GetAppData = _1_Im3d_GetAppData_;

    extern fn _1_Im3d_NewFrame_() void;
    /// Call at the start of each frame, after filling the AppData struct.
    pub const NewFrame = _1_Im3d_NewFrame_;

    extern fn _1_Im3d_EndFrame_() void;
    /// Call after all Im3d calls have been made for the current frame, before accessing draw data.
    pub const EndFrame = _1_Im3d_EndFrame_;

    extern fn _1_Im3d_GetDrawLists_() [*c]const DrawList;
    /// Access draw data. Draw lists are valid after calling EndFrame() and before calling NewFrame().
    pub const GetDrawLists = _1_Im3d_GetDrawLists_;

    extern fn _1_Im3d_GetDrawListCount_() U32;
    pub const GetDrawListCount = _1_Im3d_GetDrawListCount_;

    extern fn _1_Im3d_GetTextDrawLists_() [*c]const TextDrawList;
    /// Access to text draw data. Draw lists are valid after calling EndFrame() and before calling NewFrame().
    pub const GetTextDrawLists = _1_Im3d_GetTextDrawLists_;

    extern fn _1_Im3d_GetTextDrawListCount_() U32;
    pub const GetTextDrawListCount = _1_Im3d_GetTextDrawListCount_;

    extern fn _1_Im3d_Draw_() void;
    /// DEPRECATED (use EndFrame() + GetDrawLists()).
    /// Call after all Im3d calls have been made for the current frame.
    pub const Draw = _1_Im3d_Draw_;

    extern fn _1_Im3d_BeginPoints_() void;
    /// Begin/end primitive. End() must be called before starting each new primitive type.
    pub const BeginPoints = _1_Im3d_BeginPoints_;

    extern fn _1_Im3d_BeginLines_() void;
    pub const BeginLines = _1_Im3d_BeginLines_;

    extern fn _1_Im3d_BeginLineLoop_() void;
    pub const BeginLineLoop = _1_Im3d_BeginLineLoop_;

    extern fn _1_Im3d_BeginLineStrip_() void;
    pub const BeginLineStrip = _1_Im3d_BeginLineStrip_;

    extern fn _1_Im3d_BeginTriangles_() void;
    pub const BeginTriangles = _1_Im3d_BeginTriangles_;

    extern fn _1_Im3d_BeginTriangleStrip_() void;
    pub const BeginTriangleStrip = _1_Im3d_BeginTriangleStrip_;

    extern fn _1_Im3d_End_() void;
    pub const End = _1_Im3d_End_;

    extern fn _1_Im3d_Vertex_(_position: *const Vec3) void;
    /// Add a vertex to the current primitive (call between Begin*() and End()).
    pub const Vertex = _1_Im3d_Vertex_;

    extern fn _2_Im3d_Vertex_(_position: *const Vec3, _color: Color) void;
    pub const Vertex__Overload2 = _2_Im3d_Vertex_;

    extern fn _3_Im3d_Vertex_(_position: *const Vec3, _size: f32) void;
    pub const Vertex__Overload3 = _3_Im3d_Vertex_;

    extern fn _4_Im3d_Vertex_(_position: *const Vec3, _size: f32, _color: Color) void;
    pub const Vertex__Overload4 = _4_Im3d_Vertex_;

    extern fn _5_Im3d_Vertex_(_x: f32, _y: f32, _z: f32) void;
    pub const Vertex__Overload5 = _5_Im3d_Vertex_;

    extern fn _6_Im3d_Vertex_(_x: f32, _y: f32, _z: f32, _color: Color) void;
    pub const Vertex__Overload6 = _6_Im3d_Vertex_;

    extern fn _7_Im3d_Vertex_(_x: f32, _y: f32, _z: f32, _size: f32) void;
    pub const Vertex__Overload7 = _7_Im3d_Vertex_;

    extern fn _8_Im3d_Vertex_(_x: f32, _y: f32, _z: f32, _size: f32, _color: Color) void;
    pub const Vertex__Overload8 = _8_Im3d_Vertex_;

    extern fn _1_Im3d_PushColor_() void;
    /// Color draw state (per vertex).
    pub const PushColor = _1_Im3d_PushColor_;

    extern fn _2_Im3d_PushColor_(_color: Color) void;
    pub const PushColor__Overload2 = _2_Im3d_PushColor_;

    extern fn _1_Im3d_PopColor_() void;
    pub const PopColor = _1_Im3d_PopColor_;

    extern fn _1_Im3d_SetColor_(_color: Color) void;
    pub const SetColor = _1_Im3d_SetColor_;

    extern fn _2_Im3d_SetColor_(_r: f32, _g: f32, _b: f32, _a: f32) void;
    pub fn SetColor__Overload2(
        _r: f32,
        _g: f32,
        _b: f32,
        __opt: struct {
            _a: f32 = 1,
        },
    ) void {
        return _2_Im3d_SetColor_(_r, _g, _b, __opt._a);
    }

    extern fn _1_Im3d_GetColor_() Color;
    pub const GetColor = _1_Im3d_GetColor_;

    extern fn _1_Im3d_PushAlpha_() void;
    /// Alpha draw state, multiplies the alpha set by the color draw state (per vertex).
    pub const PushAlpha = _1_Im3d_PushAlpha_;

    extern fn _2_Im3d_PushAlpha_(_alpha: f32) void;
    pub const PushAlpha__Overload2 = _2_Im3d_PushAlpha_;

    extern fn _1_Im3d_PopAlpha_() void;
    pub const PopAlpha = _1_Im3d_PopAlpha_;

    extern fn _1_Im3d_SetAlpha_(_alpha: f32) void;
    pub const SetAlpha = _1_Im3d_SetAlpha_;

    extern fn _1_Im3d_GetAlpha_() f32;
    pub const GetAlpha = _1_Im3d_GetAlpha_;

    extern fn _1_Im3d_PushSize_() void;
    /// Size draw state, for points/lines this is the radius/width in pixels (per vertex).
    pub const PushSize = _1_Im3d_PushSize_;

    extern fn _2_Im3d_PushSize_(_size: f32) void;
    pub const PushSize__Overload2 = _2_Im3d_PushSize_;

    extern fn _1_Im3d_PopSize_() void;
    pub const PopSize = _1_Im3d_PopSize_;

    extern fn _1_Im3d_SetSize_(_size: f32) void;
    pub const SetSize = _1_Im3d_SetSize_;

    extern fn _1_Im3d_GetSize_() f32;
    pub const GetSize = _1_Im3d_GetSize_;

    extern fn _1_Im3d_PushEnableSorting_() void;
    /// Sorting draw state, enable depth sorting between primitives (per primitive).
    pub const PushEnableSorting = _1_Im3d_PushEnableSorting_;

    extern fn _2_Im3d_PushEnableSorting_(_enable: bool) void;
    pub const PushEnableSorting__Overload2 = _2_Im3d_PushEnableSorting_;

    extern fn _1_Im3d_PopEnableSorting_() void;
    pub const PopEnableSorting = _1_Im3d_PopEnableSorting_;

    extern fn _1_Im3d_EnableSorting_(_enable: bool) void;
    pub const EnableSorting = _1_Im3d_EnableSorting_;

    extern fn _1_Im3d_PushDrawState_() void;
    /// Push/pop all draw states (color, alpha, size, sorting).
    pub const PushDrawState = _1_Im3d_PushDrawState_;

    extern fn _1_Im3d_PopDrawState_() void;
    pub const PopDrawState = _1_Im3d_PopDrawState_;

    extern fn _1_Im3d_PushMatrix_() void;
    /// Transform state (per vertex).
    pub const PushMatrix = _1_Im3d_PushMatrix_;

    extern fn _2_Im3d_PushMatrix_(_mat4: *const Mat4) void;
    pub const PushMatrix__Overload2 = _2_Im3d_PushMatrix_;

    extern fn _1_Im3d_PopMatrix_() void;
    pub const PopMatrix = _1_Im3d_PopMatrix_;

    extern fn _1_Im3d_SetMatrix_(_mat4: *const Mat4) void;
    pub const SetMatrix = _1_Im3d_SetMatrix_;

    extern fn _1_Im3d_SetIdentity_() void;
    pub const SetIdentity = _1_Im3d_SetIdentity_;

    extern fn _1_Im3d_MulMatrix_(_mat4: *const Mat4) void;
    pub const MulMatrix = _1_Im3d_MulMatrix_;

    extern fn _1_Im3d_Translate_(_x: f32, _y: f32, _z: f32) void;
    pub const Translate = _1_Im3d_Translate_;

    extern fn _2_Im3d_Translate_(_vec3: *const Vec3) void;
    pub const Translate__Overload2 = _2_Im3d_Translate_;

    extern fn _1_Im3d_Rotate_(_axis: *const Vec3, _angle: f32) void;
    pub const Rotate = _1_Im3d_Rotate_;

    extern fn _2_Im3d_Rotate_(_rotation: *const Mat3) void;
    pub const Rotate__Overload2 = _2_Im3d_Rotate_;

    extern fn _1_Im3d_Scale_(_x: f32, _y: f32, _z: f32) void;
    pub const Scale = _1_Im3d_Scale_;

    extern fn _1_Im3d_DrawXyzAxes_() void;
    /// High order shapes. Where _detail = -1, an automatic level of detail is chosen based on the distance to the view origin (as specified via the AppData struct).
    pub const DrawXyzAxes = _1_Im3d_DrawXyzAxes_;

    extern fn _1_Im3d_DrawPoint_(_position: *const Vec3, _size: f32, _color: Color) void;
    pub const DrawPoint = _1_Im3d_DrawPoint_;

    extern fn _1_Im3d_DrawLine_(_a: *const Vec3, _b: *const Vec3, _size: f32, _color: Color) void;
    pub const DrawLine = _1_Im3d_DrawLine_;

    extern fn _1_Im3d_DrawQuad_(_a: *const Vec3, _b: *const Vec3, _c: *const Vec3, _d: *const Vec3) void;
    pub const DrawQuad = _1_Im3d_DrawQuad_;

    extern fn _2_Im3d_DrawQuad_(_origin: *const Vec3, _normal: *const Vec3, _size: *const Vec2) void;
    pub const DrawQuad__Overload2 = _2_Im3d_DrawQuad_;

    extern fn _1_Im3d_DrawQuadFilled_(_a: *const Vec3, _b: *const Vec3, _c: *const Vec3, _d: *const Vec3) void;
    pub const DrawQuadFilled = _1_Im3d_DrawQuadFilled_;

    extern fn _2_Im3d_DrawQuadFilled_(_origin: *const Vec3, _normal: *const Vec3, _size: *const Vec2) void;
    pub const DrawQuadFilled__Overload2 = _2_Im3d_DrawQuadFilled_;

    extern fn _1_Im3d_DrawCircle_(_origin: *const Vec3, _normal: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawCircle(
        _origin: *const Vec3,
        _normal: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawCircle_(_origin, _normal, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawCircleFilled_(_origin: *const Vec3, _normal: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawCircleFilled(
        _origin: *const Vec3,
        _normal: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawCircleFilled_(_origin, _normal, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawSphere_(_origin: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawSphere(
        _origin: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawSphere_(_origin, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawSphereFilled_(_origin: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawSphereFilled(
        _origin: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawSphereFilled_(_origin, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawAlignedBox_(_min: *const Vec3, _max: *const Vec3) void;
    pub const DrawAlignedBox = _1_Im3d_DrawAlignedBox_;

    extern fn _1_Im3d_DrawAlignedBoxFilled_(_min: *const Vec3, _max: *const Vec3) void;
    pub const DrawAlignedBoxFilled = _1_Im3d_DrawAlignedBoxFilled_;

    extern fn _1_Im3d_DrawCylinder_(_start: *const Vec3, _end: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawCylinder(
        _start: *const Vec3,
        _end: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawCylinder_(_start, _end, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawCapsule_(_start: *const Vec3, _end: *const Vec3, _radius: f32, _detail: c_int) void;
    pub fn DrawCapsule(
        _start: *const Vec3,
        _end: *const Vec3,
        _radius: f32,
        __opt: struct {
            _detail: c_int = -1,
        },
    ) void {
        return _1_Im3d_DrawCapsule_(_start, _end, _radius, __opt._detail);
    }

    extern fn _1_Im3d_DrawPrism_(_start: *const Vec3, _end: *const Vec3, _radius: f32, _sides: c_int) void;
    pub const DrawPrism = _1_Im3d_DrawPrism_;

    extern fn _1_Im3d_DrawArrow_(_start: *const Vec3, _end: *const Vec3, _headLength: f32, _headThickness: f32) void;
    pub fn DrawArrow(
        _start: *const Vec3,
        _end: *const Vec3,
        __opt: struct {
            _headLength: f32 = -1,
            _headThickness: f32 = -1,
        },
    ) void {
        return _1_Im3d_DrawArrow_(_start, _end, __opt._headLength, __opt._headThickness);
    }

    extern fn _1_Im3d_DrawCone_(_origin: *const Vec3, _normal: *const Vec3, height: f32, _radius: f32, _detail: c_int) void;
    pub const DrawCone = _1_Im3d_DrawCone_;

    extern fn _1_Im3d_DrawConeFilled_(_origin: *const Vec3, _normal: *const Vec3, height: f32, _radius: f32, _detail: c_int) void;
    pub const DrawConeFilled = _1_Im3d_DrawConeFilled_;

    extern fn _1_Im3d_MakeId_(_str: [*c]const u8) Id;
    /// IDs are used to uniquely identify gizmos and layers. Gizmo should have a unique ID during a frame.
    /// Note that ids are a hash of the whole ID stack, see PushId(), PopId().
    pub const MakeId = _1_Im3d_MakeId_;

    extern fn _2_Im3d_MakeId_(_ptr: ?*const anyopaque) Id;
    pub const MakeId__Overload2 = _2_Im3d_MakeId_;

    extern fn _3_Im3d_MakeId_(_i: c_int) Id;
    pub const MakeId__Overload3 = _3_Im3d_MakeId_;

    extern fn _1_Im3d_PushId_() void;
    /// PushId(), PopId() affect the result of subsequent calls to MakeId(), use when creating gizmos in a loop.
    pub const PushId = _1_Im3d_PushId_;

    extern fn _2_Im3d_PushId_(_id: Id) void;
    pub const PushId__Overload2 = _2_Im3d_PushId_;

    extern fn _3_Im3d_PushId_(_str: [*c]const u8) void;
    pub const PushId__Overload3 = _3_Im3d_PushId_;

    extern fn _4_Im3d_PushId_(_ptr: ?*const anyopaque) void;
    pub const PushId__Overload4 = _4_Im3d_PushId_;

    extern fn _5_Im3d_PushId_(_i: c_int) void;
    pub const PushId__Overload5 = _5_Im3d_PushId_;

    extern fn _1_Im3d_PopId_() void;
    pub const PopId = _1_Im3d_PopId_;

    extern fn _1_Im3d_GetId_() Id;
    pub const GetId = _1_Im3d_GetId_;

    extern fn _1_Im3d_PushLayerId_(_layer: Id) void;
    /// Layer id state, subsequent primitives are added to a separate draw list associated with the id (per primitive).
    pub const PushLayerId = _1_Im3d_PushLayerId_;

    extern fn _2_Im3d_PushLayerId_(_str: [*c]const u8) void;
    pub const PushLayerId__Overload2 = _2_Im3d_PushLayerId_;

    extern fn _1_Im3d_PopLayerId_() void;
    pub const PopLayerId = _1_Im3d_PopLayerId_;

    extern fn _1_Im3d_GetLayerId_() Id;
    pub const GetLayerId = _1_Im3d_GetLayerId_;

    extern fn _1_Im3d_GizmoTranslation_(_id: [*c]const u8, _translation_: [*c]f32, _local: bool) bool;
    /// Manipulate translation/rotation/scale via a gizmo. Return true if the gizmo is 'active' (if it modified the output parameter).
    /// If _local is true, the Gizmo* functions expect that the local matrix is on the matrix stack; in general the application should
    /// push the local matrix before calling any of the following.
    pub fn GizmoTranslation(
        _id: [*c]const u8,
        _translation_: [*c]f32,
        __opt: struct {
            _local: bool = false,
        },
    ) bool {
        return _1_Im3d_GizmoTranslation_(_id, _translation_, __opt._local);
    }

    extern fn _1_Im3d_GizmoRotation_(_id: [*c]const u8, _rotation_: [*c]f32, _local: bool) bool;
    pub fn GizmoRotation(
        _id: [*c]const u8,
        _rotation_: [*c]f32,
        __opt: struct {
            _local: bool = false,
        },
    ) bool {
        return _1_Im3d_GizmoRotation_(_id, _rotation_, __opt._local);
    }

    extern fn _1_Im3d_GizmoScale_(_id: [*c]const u8, _scale_: [*c]f32) bool;
    pub const GizmoScale = _1_Im3d_GizmoScale_;

    extern fn _1_Im3d_Gizmo_(_id: [*c]const u8, _translation_: [*c]f32, _rotation_: [*c]f32, _scale_: [*c]f32) bool;
    /// Unified gizmo, selects local/global, translation/rotation/scale based on the context-global gizmo modes. Return true if the gizmo is active.
    pub const Gizmo = _1_Im3d_Gizmo_;

    extern fn _2_Im3d_Gizmo_(_id: [*c]const u8, _transform_: [*c]f32) bool;
    pub const Gizmo__Overload2 = _2_Im3d_Gizmo_;

    extern fn _2_Im3d_GizmoTranslation_(_id: Id, _translation_: [*c]f32, _local: bool) bool;
    /// Gizmo* overloads which take an ID directly. In some cases the app may want to call MakeId() separately, usually to change the gizmo appearance if hot/active.
    pub fn GizmoTranslation__Overload2(
        _id: Id,
        _translation_: [*c]f32,
        __opt: struct {
            _local: bool = false,
        },
    ) bool {
        return _2_Im3d_GizmoTranslation_(_id, _translation_, __opt._local);
    }

    extern fn _2_Im3d_GizmoRotation_(_id: Id, _rotation_: [*c]f32, _local: bool) bool;
    pub fn GizmoRotation__Overload2(
        _id: Id,
        _rotation_: [*c]f32,
        __opt: struct {
            _local: bool = false,
        },
    ) bool {
        return _2_Im3d_GizmoRotation_(_id, _rotation_, __opt._local);
    }

    extern fn _2_Im3d_GizmoScale_(_id: Id, _scale_: [*c]f32) bool;
    pub const GizmoScale__Overload2 = _2_Im3d_GizmoScale_;

    extern fn _3_Im3d_Gizmo_(_id: Id, _transform_: [*c]f32) bool;
    pub const Gizmo__Overload3 = _3_Im3d_Gizmo_;

    extern fn _4_Im3d_Gizmo_(_id: Id, _translation_: [*c]f32, _rotation_: [*c]f32, _scale_: [*c]f32) bool;
    pub const Gizmo__Overload4 = _4_Im3d_Gizmo_;

    extern fn _1_Im3d_GetActiveId_() Id;
    /// Active gizmo ID. This will match the _id parameter passed to a Gizmo* function. Return Id_Invalid if no gizmo is in use.
    pub const GetActiveId = _1_Im3d_GetActiveId_;

    extern fn _1_Im3d_GetHotId_() Id;
    /// ID of the current current 'hot' gizmo (nearest intersecting gizmo along the cursor ray).
    pub const GetHotId = _1_Im3d_GetHotId_;

    extern fn _1_Im3d_IsVisible_(_origin: *const Vec3, _radius: f32) bool;
    /// Visibility tests. The application must set a culling frustum via AppData.
    pub const IsVisible = _1_Im3d_IsVisible_;

    extern fn _2_Im3d_IsVisible_(_min: *const Vec3, _max: *const Vec3) bool;
    pub const IsVisible__Overload2 = _2_Im3d_IsVisible_;

    extern fn _1_Im3d_GetContext_() *Context;
    /// Get/set the current context. All Im3d calls affect the currently bound context.
    pub const GetContext = _1_Im3d_GetContext_;

    extern fn _1_Im3d_SetContext_(_ctx: *Context) void;
    pub const SetContext = _1_Im3d_SetContext_;

    extern fn _1_Im3d_MergeContexts_(_dst_: *Context, _src: *const Context) void;
    /// Merge vertex data from _src into _dst_. Layers are preserved. Call before EndFrame().
    pub const MergeContexts = _1_Im3d_MergeContexts_;

    pub const Vec2 = extern struct {
        x: f32,
        y: f32,

        extern fn _1_Im3d_Vec2_init_(self: *Vec2) void;
        pub const init = _1_Im3d_Vec2_init_;

        extern fn _2_Im3d_Vec2_init_(self: *Vec2, _xy: f32) void;
        pub const init2 = _2_Im3d_Vec2_init_;

        extern fn _3_Im3d_Vec2_init_(self: *Vec2, _x: f32, _y: f32) void;
        pub const init3 = _3_Im3d_Vec2_init_;
    };

    pub const Vec3 = extern struct {
        x: f32,
        y: f32,
        z: f32,

        extern fn _1_Im3d_Vec3_init_(self: *Vec3) void;
        pub const init = _1_Im3d_Vec3_init_;

        extern fn _2_Im3d_Vec3_init_(self: *Vec3, _xyz: f32) void;
        pub const init2 = _2_Im3d_Vec3_init_;

        extern fn _3_Im3d_Vec3_init_(self: *Vec3, _x: f32, _y: f32, _z: f32) void;
        pub const init3 = _3_Im3d_Vec3_init_;

        extern fn _4_Im3d_Vec3_init_(self: *Vec3, _xy: *const Vec2, _z: f32) void;
        pub const init4 = _4_Im3d_Vec3_init_;

        extern fn _5_Im3d_Vec3_init_(self: *Vec3, _v: *const Vec4) void;
        pub const init5 = _5_Im3d_Vec3_init_;
    };

    pub const Vec4 = extern struct {
        x: f32,
        y: f32,
        z: f32,
        w: f32,

        extern fn _1_Im3d_Vec4_init_(self: *Vec4) void;
        pub const init = _1_Im3d_Vec4_init_;

        extern fn _2_Im3d_Vec4_init_(self: *Vec4, _xyzw: f32) void;
        pub const init2 = _2_Im3d_Vec4_init_;

        extern fn _3_Im3d_Vec4_init_(self: *Vec4, _x: f32, _y: f32, _z: f32, _w: f32) void;
        pub const init3 = _3_Im3d_Vec4_init_;

        extern fn _4_Im3d_Vec4_init_(self: *Vec4, _xyz: *const Vec3, _w: f32) void;
        pub const init4 = _4_Im3d_Vec4_init_;

        extern fn _5_Im3d_Vec4_init_(self: *Vec4, _rgba: Color) void;
        pub const init5 = _5_Im3d_Vec4_init_;
    };

    pub const Mat3 = extern struct {
        /// column-major unless IM3D_MATRIX_ROW_MAJOR defined
        m: [9]f32,

        extern fn _1_Im3d_Mat3_init_(self: *Mat3) void;
        pub const init = _1_Im3d_Mat3_init_;

        extern fn _2_Im3d_Mat3_init_(self: *Mat3, _diagonal: f32) void;
        pub const init2 = _2_Im3d_Mat3_init_;

        extern fn _3_Im3d_Mat3_init_(self: *Mat3, m00: f32, m01: f32, m02: f32, m10: f32, m11: f32, m12: f32, m20: f32, m21: f32, m22: f32) void;
        pub const init3 = _3_Im3d_Mat3_init_;

        extern fn _4_Im3d_Mat3_init_(self: *Mat3, _colX: *const Vec3, _colY: *const Vec3, _colZ: *const Vec3) void;
        pub const init4 = _4_Im3d_Mat3_init_;

        extern fn _5_Im3d_Mat3_init_(self: *Mat3, _mat4: *const Mat4) void;
        pub const init5 = _5_Im3d_Mat3_init_;

        extern fn _1_Im3d_Mat3_getCol_(self: *const Mat3, _i: c_int) Vec3;
        pub const getCol = _1_Im3d_Mat3_getCol_;

        extern fn _1_Im3d_Mat3_getRow_(self: *const Mat3, _i: c_int) Vec3;
        pub const getRow = _1_Im3d_Mat3_getRow_;

        extern fn _1_Im3d_Mat3_setCol_(self: *Mat3, _i: c_int, _v: *const Vec3) void;
        pub const setCol = _1_Im3d_Mat3_setCol_;

        extern fn _1_Im3d_Mat3_setRow_(self: *Mat3, _i: c_int, _v: *const Vec3) void;
        pub const setRow = _1_Im3d_Mat3_setRow_;

        extern fn _1_Im3d_Mat3_getScale_(self: *const Mat3) Vec3;
        pub const getScale = _1_Im3d_Mat3_getScale_;

        extern fn _1_Im3d_Mat3_setScale_(self: *Mat3, _scale: *const Vec3) void;
        pub const setScale = _1_Im3d_Mat3_setScale_;

        pub fn call(self: *const Mat3, _row: c_int, _col: c_int) f32 {
            const i: c_int = _col * 3 + _row;
            return &self.m[i];
        }
        pub fn call__Overload2(self: *Mat3, _row: c_int, _col: c_int) *f32 {
            const i: c_int = _col * 3 + _row;
            return &self.m[i];
        }
    };

    pub const Mat4 = extern struct {
        /// column-major unless IM3D_MATRIX_ROW_MAJOR defined
        m: [16]f32,

        extern fn _1_Im3d_Mat4_init_(self: *Mat4) void;
        pub const init = _1_Im3d_Mat4_init_;

        extern fn _2_Im3d_Mat4_init_(self: *Mat4, _diagonal: f32) void;
        pub const init2 = _2_Im3d_Mat4_init_;

        extern fn _3_Im3d_Mat4_init_(self: *Mat4, m00: f32, m01: f32, m02: f32, m03: f32, m10: f32, m11: f32, m12: f32, m13: f32, m20: f32, m21: f32, m22: f32, m23: f32, m30: f32, m31: f32, m32: f32, m33: f32) void;
        pub const init3 = _3_Im3d_Mat4_init_;

        extern fn _4_Im3d_Mat4_init_(self: *Mat4, _mat3: *const Mat3) void;
        pub const init4 = _4_Im3d_Mat4_init_;

        extern fn _5_Im3d_Mat4_init_(self: *Mat4, _translation: *const Vec3, _rotation: *const Mat3, _scale: *const Vec3) void;
        pub const init5 = _5_Im3d_Mat4_init_;

        extern fn _1_Im3d_Mat4_getCol_(self: *const Mat4, _i: c_int) Vec4;
        pub const getCol = _1_Im3d_Mat4_getCol_;

        extern fn _1_Im3d_Mat4_getRow_(self: *const Mat4, _i: c_int) Vec4;
        pub const getRow = _1_Im3d_Mat4_getRow_;

        extern fn _1_Im3d_Mat4_setCol_(self: *Mat4, _i: c_int, _v: *const Vec4) void;
        pub const setCol = _1_Im3d_Mat4_setCol_;

        extern fn _1_Im3d_Mat4_setRow_(self: *Mat4, _i: c_int, _v: *const Vec4) void;
        pub const setRow = _1_Im3d_Mat4_setRow_;

        extern fn _1_Im3d_Mat4_getTranslation_(self: *const Mat4) Vec3;
        pub const getTranslation = _1_Im3d_Mat4_getTranslation_;

        extern fn _1_Im3d_Mat4_setTranslation_(self: *Mat4, _translation: *const Vec3) void;
        pub const setTranslation = _1_Im3d_Mat4_setTranslation_;

        extern fn _1_Im3d_Mat4_getRotation_(self: *const Mat4) Mat3;
        pub const getRotation = _1_Im3d_Mat4_getRotation_;

        extern fn _1_Im3d_Mat4_setRotation_(self: *Mat4, _rotation: *const Mat3) void;
        pub const setRotation = _1_Im3d_Mat4_setRotation_;

        extern fn _1_Im3d_Mat4_getScale_(self: *const Mat4) Vec3;
        pub const getScale = _1_Im3d_Mat4_getScale_;

        extern fn _1_Im3d_Mat4_setScale_(self: *Mat4, _scale: *const Vec3) void;
        pub const setScale = _1_Im3d_Mat4_setScale_;

        pub fn call(self: *const Mat4, _row: c_int, _col: c_int) f32 {
            const i: c_int = _col * 4 + _row;
            return &self.m[i];
        }
        pub fn call__Overload2(self: *Mat4, _row: c_int, _col: c_int) *f32 {
            const i: c_int = _col * 4 + _row;
            return &self.m[i];
        }
    };

    pub const Color = extern struct {
        /// rgba8 (MSB = r)
        v: U32,

        extern fn _1_Im3d_Color_init_(self: *Color) void;
        pub const init = _1_Im3d_Color_init_;

        extern fn _2_Im3d_Color_init_(self: *Color, _rgba: U32) void;
        pub const init2 = _2_Im3d_Color_init_;

        extern fn _3_Im3d_Color_init_(self: *Color, _rgba: *const Vec4) void;
        pub const init3 = _3_Im3d_Color_init_;

        extern fn _4_Im3d_Color_init_(self: *Color, _rgb: *const Vec3, _alpha: f32) void;
        pub const init4 = _4_Im3d_Color_init_;

        extern fn _5_Im3d_Color_init_(self: *Color, _r: f32, _g: f32, _b: f32, _a: f32) void;
        pub const init5 = _5_Im3d_Color_init_;

        // syntax errors:
        // pub fn set(self: *Color, _i: c_int, _val: f32) void {
        // _i *= 8;
        // var mask: U32 = @as(U32, @intCast(255 << _i));
        // self.v = (self.v & ~mask) | ( << _i);
        // }
        //
        pub fn setR(self: *Color, _val: f32) void {
            self.set(3, _val);
        }
        pub fn setG(self: *Color, _val: f32) void {
            self.set(2, _val);
        }
        pub fn setB(self: *Color, _val: f32) void {
            self.set(1, _val);
        }
        pub fn setA(self: *Color, _val: f32) void {
            self.set(0, _val);
        }
        pub fn get(self: *const Color, _i: c_int) f32 {
            _i *= 8;
            const mask: U32 = @intCast(255 << _i);
            return ((self.v & mask) >> _i) / 255;
        }
        pub fn getR(self: *const Color) f32 {
            return self.get(3);
        }
        pub fn getG(self: *const Color) f32 {
            return self.get(2);
        }
        pub fn getB(self: *const Color) f32 {
            return self.get(1);
        }
        pub fn getA(self: *const Color) f32 {
            return self.get(0);
        }
        pub fn getABGR(self: *const Color) U32 {
            return @as(U32, @intCast(0)) | ((self.v & @as(U32, @intCast((255 << 24)))) >> 24) | ((self.v & @as(U32, @intCast((255 << 16)))) >> 8) | ((self.v & @as(U32, @intCast((255 << 8)))) << 8) | ((self.v & @as(U32, @intCast((255)))) << 24);
        }
    };

    extern const _1_Im3d_Color_Black_: *const Color;
    pub const Color_Black = _1_Im3d_Color_Black_;

    extern const _1_Im3d_Color_White_: *const Color;
    pub const Color_White = _1_Im3d_Color_White_;

    extern const _1_Im3d_Color_Gray_: *const Color;
    pub const Color_Gray = _1_Im3d_Color_Gray_;

    extern const _1_Im3d_Color_Red_: *const Color;
    pub const Color_Red = _1_Im3d_Color_Red_;

    extern const _1_Im3d_Color_Green_: *const Color;
    pub const Color_Green = _1_Im3d_Color_Green_;

    extern const _1_Im3d_Color_Blue_: *const Color;
    pub const Color_Blue = _1_Im3d_Color_Blue_;

    extern const _1_Im3d_Color_Magenta_: *const Color;
    pub const Color_Magenta = _1_Im3d_Color_Magenta_;

    extern const _1_Im3d_Color_Yellow_: *const Color;
    pub const Color_Yellow = _1_Im3d_Color_Yellow_;

    extern const _1_Im3d_Color_Cyan_: *const Color;
    pub const Color_Cyan = _1_Im3d_Color_Cyan_;

    extern const _1_Im3d_Color_Pink_: *const Color;
    pub const Color_Pink = _1_Im3d_Color_Pink_;

    extern const _1_Im3d_Color_Orange_: *const Color;
    pub const Color_Orange = _1_Im3d_Color_Orange_;

    extern const _1_Im3d_Color_Gold_: *const Color;
    pub const Color_Gold = _1_Im3d_Color_Gold_;

    extern const _1_Im3d_Color_Brown_: *const Color;
    pub const Color_Brown = _1_Im3d_Color_Brown_;

    extern const _1_Im3d_Color_Purple_: *const Color;
    pub const Color_Purple = _1_Im3d_Color_Purple_;

    extern const _1_Im3d_Color_Teal_: *const Color;
    pub const Color_Teal = _1_Im3d_Color_Teal_;

    extern const _1_Im3d_Color_Navy_: *const Color;
    pub const Color_Navy = _1_Im3d_Color_Navy_;

    pub const VertexData = extern struct {
        /// xyz = position, w = size
        m_positionSize: Vec4,
        /// rgba8 (MSB = r)
        m_color: Color,

        extern fn _1_Im3d_VertexData_init_(self: *VertexData) void;
        pub const init = _1_Im3d_VertexData_init_;

        extern fn _2_Im3d_VertexData_init_(self: *VertexData, _position: *const Vec3, _size: f32, _color: Color) void;
        pub const init2 = _2_Im3d_VertexData_init_;
    };

    pub const DrawPrimitiveType = extern struct {
        bits: c_int = 0,

        /// order here determines the order in which unsorted primitives are drawn
        pub const DrawPrimitive_Triangles: DrawPrimitiveType = .{ .bits = 0 };
        /// order here determines the order in which unsorted primitives are drawn
        pub const DrawPrimitive_Lines: DrawPrimitiveType = .{ .bits = 1 };
        /// order here determines the order in which unsorted primitives are drawn
        pub const DrawPrimitive_Points: DrawPrimitiveType = .{ .bits = 2 };
        /// order here determines the order in which unsorted primitives are drawn
        pub const DrawPrimitive_Count: DrawPrimitiveType = .{ .bits = 3 };

        // pub usingnamespace cpp.FlagsMixin(DrawPrimitiveType);
    };

    pub const DrawList = extern struct {
        m_layerId: Id,
        m_primType: DrawPrimitiveType,
        m_vertexData: [*c]const VertexData,
        m_vertexCount: U32,
    };

    pub const DrawPrimitivesCallback = fn (*const DrawList) callconv(.C) void;

    pub const TextFlags = extern struct {
        bits: c_int = 0,

        pub const _AlignLeft: TextFlags = .{ .bits = @as(c_uint, @intCast((1 << 0))) };
        pub const _AlignRight: TextFlags = .{ .bits = @as(c_uint, @intCast((1 << 1))) };
        pub const _AlignTop: TextFlags = .{ .bits = @as(c_uint, @intCast((1 << 3))) };
        pub const _AlignBottom: TextFlags = .{ .bits = @as(c_uint, @intCast((1 << 4))) };
        /// align center
        pub const _Default: TextFlags = .{ .bits = @as(c_uint, @intCast(0)) };

        // pub usingnamespace cpp.FlagsMixin(TextFlags);
    };

    pub const TextData = extern struct {
        /// xyz = position, w = size
        m_positionSize: Vec4,
        /// rgba8 (MSB = r)
        m_color: Color,
        /// TextFlags
        m_flags: U32,
        /// # chars in the text, excluding null terminator
        m_textLength: U32,
        /// start of the text in the draw list's text buffer
        m_textBufferOffset: U32,
    };

    pub const TextDrawList = extern struct {
        m_layerId: Id,
        m_textData: [*c]const TextData,
        m_textDataCount: U32,
        m_textBuffer: [*c]const u8,
    };

    pub const Key = extern struct {
        bits: c_int = 0,

        pub const Mouse_Left: Key = .{ .bits = 0 };
        pub const Key_L: Key = .{ .bits = 1 };
        pub const Key_R: Key = .{ .bits = 2 };
        pub const Key_S: Key = .{ .bits = 3 };
        pub const Key_T: Key = .{ .bits = 4 };
        pub const Key_Count: Key = .{ .bits = 5 };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_Select: Key = .{ .bits = @as(c_uint, @intCast(Mouse_Left.bits)) };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_GizmoLocal: Key = .{ .bits = @as(c_uint, @intCast(Key_L.bits)) };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_GizmoRotation: Key = .{ .bits = @as(c_uint, @intCast(Key_R.bits)) };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_GizmoScale: Key = .{ .bits = @as(c_uint, @intCast(Key_S.bits)) };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_GizmoTranslation: Key = .{ .bits = @as(c_uint, @intCast(Key_T.bits)) };
        /// the following map keys -> 'action' states which may be more intuitive
        pub const Action_Count: Key = .{ .bits = Key.Action_GizmoTranslation.bits + 1 };

        // pub usingnamespace cpp.FlagsMixin(Key);
    };

    pub const FrustumPlane = extern struct {
        bits: c_int = 0,

        pub const _Near: FrustumPlane = .{ .bits = 0 };
        pub const _Far: FrustumPlane = .{ .bits = 1 };
        pub const _Top: FrustumPlane = .{ .bits = 2 };
        pub const _Right: FrustumPlane = .{ .bits = 3 };
        pub const _Bottom: FrustumPlane = .{ .bits = 4 };
        pub const _Left: FrustumPlane = .{ .bits = 5 };
        pub const _Count: FrustumPlane = .{ .bits = 6 };

        // pub usingnamespace cpp.FlagsMixin(FrustumPlane);
    };

    pub const AppData = extern struct {
        /// Key states.
        m_keyDown: [5]bool,
        /// Frustum planes for culling (if culling enabled).
        m_cullFrustum: [6]Vec4,
        /// World space cursor ray origin.
        m_cursorRayOrigin: Vec3,
        /// World space cursor ray direction.
        m_cursorRayDirection: Vec3,
        /// World space 'up' vector.
        m_worldUp: Vec3 = Vec3.init(0, 1, 0),
        /// World space render origin (camera position).
        m_viewOrigin: Vec3,
        /// World space view direction.
        m_viewDirection: Vec3,
        /// Viewport size (pixels).
        m_viewportSize: Vec2,
        /// Scale factor used to convert from pixel size -> world scale; use tan(fov) for perspective projections, far plane height for ortho.
        m_projScaleY: f32 = 1,
        /// If the projection matrix is orthographic.
        m_projOrtho: bool = false,
        /// Time since previous frame (seconds).
        m_deltaTime: f32 = 0,
        /// Snap value for translation gizmos (world units). 0 = disabled.
        m_snapTranslation: f32 = 0,
        /// Snap value for rotation gizmos (radians). 0 = disabled.
        m_snapRotation: f32 = 0,
        /// Snap value for scale gizmos. 0 = disabled.
        m_snapScale: f32 = 0,
        /// Flip gizmo axes when viewed from behind.
        m_flipGizmoWhenBehind: bool = true,
        /// App-specific data.
        m_appData: ?*anyopaque = null,
        /// e.g. void Im3d_Draw(const DrawList
        ///&
        /// _drawList)
        drawCallback: [*c]DrawPrimitivesCallback = null,

        extern fn _1_Im3d_AppData_setCullFrustum_(self: *AppData, _viewProj: *const Mat4, _ndcZNegativeOneToOne: bool) void;
        /// Extract cull frustum planes from the view-projection matrix.
        /// Set _ndcZNegativeOneToOne = true if the proj matrix maps z from [-1,1] (OpenGL style).
        pub const setCullFrustum = _1_Im3d_AppData_setCullFrustum_;
    };

    pub fn Vector(comptime T: type) type {
        return extern struct {
            const Self = @This();

            m_data: [*c]T,
            m_size: U32,
            m_capacity: U32,

            // syntax errors:
            // pub fn getPtr(self: *Self, _i: U32) *T {
            // _ = (((!!(_i < self.m_size)) or (((_assert(&"\"_i < m_size\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(548))); 0)) != 0)));
            // ;
            // return self.m_data[_i];
            // }
            //
            // syntax errors:
            // pub fn get(self: *const Self, _i: U32) *const T {
            // _ = (((!!(_i < self.m_size)) or (((_assert(&"\"_i < m_size\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(549))); 0)) != 0)));
            // ;
            // return self.m_data[_i];
            // }
            //
            pub fn data(self: *Self) [*c]T {
                return self.m_data;
            }
            pub fn data__Overload2(self: *const Self) [*c]const T {
                return self.m_data;
            }
            // syntax errors:
            // pub fn push_back(self: *Self) *T {
            //  if (self.m_size == self.m_capacity) {
            // self.reserve(self.m_capacity + self.m_capacity / @as(U32, @intCast(2)));
            // }return self.m_data[self.m_size += 1];
            // }
            //
            // syntax errors:
            // pub fn push_back__Overload2(self: *Self, _v: *const T) void {
            // var tmp: T = _v;
            //  if (self.m_size == self.m_capacity) {
            // self.reserve(self.m_capacity + self.m_capacity / @as(U32, @intCast(2)));
            // }self.m_data[self.m_size += 1] = tmp;
            // }
            //
            // syntax errors:
            // pub fn pop_back(self: *Self) void {
            // _ = (((!!(self.m_size > @as(U32, @intCast(0)))) or (((_assert(&"\"m_size > 0\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(555))); 0)) != 0)));
            // ;
            // self.m_size -= 1;
            // }
            //
            pub extern fn append(self: *Self, _v: [*c]const T, _count: U32) void;
            // syntax errors:
            // pub fn append__Overload2(self: *Self, _other: *const Vector(T)) void {
            // 0=0=UnresolvedMemberExpr(_other.data(), _other.size());
            // }
            //
            pub fn begin(self: *Self) [*c]T {
                return self.m_data;
            }
            pub fn begin__Overload2(self: *const Self) [*c]const T {
                return self.m_data;
            }
            pub fn end(self: *Self) [*c]T {
                return self.m_data + self.m_size;
            }
            pub fn end__Overload2(self: *const Self) [*c]const T {
                return self.m_data + self.m_size;
            }
            // syntax errors:
            // pub fn front(self: *Self) *T {
            // _ = (((!!(self.m_size > @as(U32, @intCast(0)))) or (((_assert(&"\"m_size > 0\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(563))); 0)) != 0)));
            // ;
            // return self.m_data[0];
            // }
            //
            // syntax errors:
            // pub fn front__Overload2(self: *const Self) *const T {
            // _ = (((!!(self.m_size > @as(U32, @intCast(0)))) or (((_assert(&"\"m_size > 0\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(564))); 0)) != 0)));
            // ;
            // return self.m_data[0];
            // }
            //
            // syntax errors:
            pub fn back(self: *Self) *T {
                std.debug.assert(self.m_size > 0);
                return self.m_data[self.m_size - 1];
            }
            pub fn size(self: *const Self) U32 {
                return self.m_size;
            }
            pub fn capacity(self: *const Self) U32 {
                return self.m_capacity;
            }
            pub fn empty(self: *const Self) bool {
                return self.m_size == @as(U32, @intCast(0));
            }
            pub fn clear(self: *Self) void {
                self.m_size = @as(U32, @intCast(0));
            }
            pub extern fn reserve(self: *Self, _capacity: U32) void;
            // pub extern fn resize_and_set(self: *Self, _size: U32, _val: *const T) void;
            pub extern fn resize(self: *Self, _size: U32) void;
            pub extern fn swap(_a_: *Vector(T), _b_: *Vector(T)) void;
        };
    }

    pub const PrimitiveMode = extern struct {
        bits: c_int = 0,

        pub const _None: PrimitiveMode = .{ .bits = 0 };
        pub const _Points: PrimitiveMode = .{ .bits = 1 };
        pub const _Lines: PrimitiveMode = .{ .bits = 2 };
        pub const _LineStrip: PrimitiveMode = .{ .bits = 3 };
        pub const _LineLoop: PrimitiveMode = .{ .bits = 4 };
        pub const _Triangles: PrimitiveMode = .{ .bits = 5 };
        pub const _TriangleStrip: PrimitiveMode = .{ .bits = 6 };

        // pub usingnamespace cpp.FlagsMixin(PrimitiveMode);
    };

    pub const GizmoMode = extern struct {
        bits: c_int = 0,

        pub const _Translation: GizmoMode = .{ .bits = 0 };
        pub const _Rotation: GizmoMode = .{ .bits = 1 };
        pub const _Scale: GizmoMode = .{ .bits = 2 };

        // pub usingnamespace cpp.FlagsMixin(GizmoMode);
    };

    /// Context stores all relevant state - main interface affects the context currently bound via SetCurrentContext().
    pub const Context = extern struct {
        const VertexList = Vector(VertexData);
        const TextList = Vector(TextData);

        /// Global mode selection for gizmos.
        m_gizmoLocal: bool,
        ///               "
        m_gizmoMode: GizmoMode,
        /// Currently active gizmo. If set, this is the same as m_hotId.
        m_activeId: Id,
        /// ID of the current 'hot' gizmo (nearest intersecting gizmo along the cursor ray). NB this is the id of the *sub* gizmo, not the app-specified ID.
        m_hotId: Id,
        /// Depth of the current hot gizmo along the cursor ray, for handling occlusion.
        m_hotDepth: f32,
        /// Current ID *without* the hashing the ID stack (= _id arg to Gizmo* functions).
        m_appId: Id,
        /// Copied from m_appId for the current active gizmo.
        m_appActiveId: Id,
        /// Copied from m_appId for the current 'hot' gizmo.
        m_appHotId: Id,
        /// Stored state for the active gizmo.
        m_gizmoStateVec3: Vec3,
        ///               "
        m_gizmoStateMat3: Mat3,
        ///               "
        m_gizmoStateFloat: f32,
        /// Height/radius of gizmos.
        m_gizmoHeightPixels: f32,
        /// Thickness of gizmo lines.
        m_gizmoSizePixels: f32,
        /// State stacks.
        m_colorStack: Vector(Color),
        m_alphaStack: Vector(f32),
        m_sizeStack: Vector(f32),
        m_enableSortingStack: Vector(bool),
        m_matrixStack: Vector(Mat4),
        m_idStack: Vector(Id),
        m_layerIdStack: Vector(Id),
        /// Each layer is DrawPrimitive_Count consecutive lists.
        m_vertexData: [2]Vector([*c]VertexList),
        /// 0, or 1 if sorting enabled.
        m_vertexDataIndex: c_int,
        /// Map Id -> vertex data index.
        m_layerIdMap: Vector(Id),
        /// Index of the currently active layer in m_layerIdMap.
        m_layerIndex: c_int,
        /// All draw lists for the current frame, available after calling endFrame() before calling reset().
        m_drawLists: Vector(DrawList),
        /// Avoid calling sort() during every call to draw().
        m_sortCalled: bool,
        /// For assert, if vertices are pushed after endFrame() was called.
        m_endFrameCalled: bool,
        m_textData: Vector([*c]TextList),
        m_textBuffer: Vector(u8),
        m_textDrawLists: Vector(TextDrawList),
        /// Primitive state.
        m_primMode: PrimitiveMode,
        m_primType: DrawPrimitiveType,
        /// Index of the first vertex pushed during this primitive.
        m_firstVertThisPrim: U32,
        /// # calls to vertex() since the last call to begin().
        m_vertCountThisPrim: U32,
        m_minVertThisPrim: Vec3,
        m_maxVertThisPrim: Vec3,
        /// App data.
        m_appData: AppData,
        /// Key state captured during reset().
        m_keyDownCurr: [5]bool,
        /// Key state from previous frame.
        m_keyDownPrev: [5]bool,
        /// Optimized frustum planes from m_appData.m_cullFrustum.
        m_cullFrustum: [6]Vec4,
        /// # valid frustum planes in m_cullFrustum.
        m_cullFrustumCount: c_int,

        extern fn _1_Im3d_Context_init_(self: *Context) void;
        pub const init = _1_Im3d_Context_init_;

        extern fn _1_Im3d_Context_deinit_(self: *Context) void;
        pub const deinit = _1_Im3d_Context_deinit_;

        extern fn _1_Im3d_Context_begin_(self: *Context, _mode: PrimitiveMode) void;
        pub const begin = _1_Im3d_Context_begin_;

        extern fn _1_Im3d_Context_end_(self: *Context) void;
        pub const end = _1_Im3d_Context_end_;

        extern fn _1_Im3d_Context_vertex_(self: *Context, _position: *const Vec3, _size: f32, _color: Color) void;
        pub const vertex = _1_Im3d_Context_vertex_;

        pub fn vertex__Overload2(self: *Context, _position: *const Vec3) void {
            self.vertex(_position, self.getSize(), self.getColor());
        }
        extern fn _1_Im3d_Context_text_(self: *Context, _position: *const Vec3, _size: f32, _color: Color, _flags: TextFlags, _textStart: [*c]const u8, _textEnd: [*c]const u8) void;
        pub const text = _1_Im3d_Context_text_;

        extern fn _2_Im3d_Context_text_(self: *Context, _position: *const Vec3, _size: f32, _color: Color, _flags: TextFlags, _text: [*c]const u8, _args: [*c]u8) void;
        pub const text__Overload2 = _2_Im3d_Context_text_;

        extern fn _1_Im3d_Context_reset_(self: *Context) void;
        pub const reset = _1_Im3d_Context_reset_;

        extern fn _1_Im3d_Context_merge_(self: *Context, _src: *const Context) void;
        pub const merge = _1_Im3d_Context_merge_;

        extern fn _1_Im3d_Context_endFrame_(self: *Context) void;
        pub const endFrame = _1_Im3d_Context_endFrame_;

        extern fn _1_Im3d_Context_draw_(self: *Context) void;
        pub const draw = _1_Im3d_Context_draw_;

        pub fn getDrawLists(self: *const Context) [*c]const DrawList {
            return self.data();
        }
        pub fn getDrawListCount(self: *const Context) U32 {
            return self.size();
        }
        pub fn getTextDrawLists(self: *const Context) [*c]const TextDrawList {
            return self.data();
        }
        pub fn getTextDrawListCount(self: *const Context) U32 {
            return self.size();
        }
        pub fn setColor(self: *Context, _color: Color) void {
            self.back().copyFrom(_color);
        }
        pub fn getColor(self: *const Context) Color {
            _ = self; // autofix
            return;
        }
        pub fn pushColor(self: *Context, _color: Color) void {
            self.push_back(_color);
        }
        // syntax errors:
        // pub fn popColor(self: *Context) void {
        // _ = (((!!(self.size() > @as(U32, @intCast(1)))) or (((_assert(&"\"m_colorStack.size() > 1\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(634))); 0)) != 0)));
        // ;
        // self.pop_back();
        // }
        //
        pub fn setAlpha(self: *Context, _alpha: f32) void {
            self.back().* = _alpha;
        }
        pub fn getAlpha(self: *const Context) f32 {
            return self.back();
        }
        pub fn pushAlpha(self: *Context, _alpha: f32) void {
            self.push_back(_alpha);
        }
        // syntax errors:
        // pub fn popAlpha(self: *Context) void {
        // _ = (((!!(self.size() > @as(U32, @intCast(1)))) or (((_assert(&"\"m_alphaStack.size() > 1\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(639))); 0)) != 0)));
        // ;
        // self.pop_back();
        // }
        //
        pub fn setSize(self: *Context, _size: f32) void {
            var b = self.m_sizeStack.back();
            b = _size;
        }
        pub fn getSize(self: *const Context) f32 {
            return self.back();
        }
        pub fn pushSize(self: *Context, _size: f32) void {
            self.push_back(_size);
        }
        // syntax errors:
        // pub fn popSize(self: *Context) void {
        // _ = (((!!(self.size() > @as(U32, @intCast(1)))) or (((_assert(&"\"m_sizeStack.size() > 1\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(644))); 0)) != 0)));
        // ;
        // self.pop_back();
        // }
        //
        extern fn _1_Im3d_Context_setEnableSorting_(self: *Context, _enable: bool) void;
        pub const setEnableSorting = _1_Im3d_Context_setEnableSorting_;

        pub fn getEnableSorting(self: *const Context) bool {
            return self.back();
        }
        extern fn _1_Im3d_Context_pushEnableSorting_(self: *Context, _enable: bool) void;
        pub const pushEnableSorting = _1_Im3d_Context_pushEnableSorting_;

        extern fn _1_Im3d_Context_popEnableSorting_(self: *Context) void;
        pub const popEnableSorting = _1_Im3d_Context_popEnableSorting_;

        pub fn getLayerId(self: *const Context) Id {
            return self.back();
        }
        extern fn _1_Im3d_Context_pushLayerId_(self: *Context, _layer: Id) void;
        pub const pushLayerId = _1_Im3d_Context_pushLayerId_;

        extern fn _1_Im3d_Context_popLayerId_(self: *Context) void;
        pub const popLayerId = _1_Im3d_Context_popLayerId_;

        pub fn setMatrix(self: *Context, _mat4: *const Mat4) void {
            self.back().copyFrom(_mat4);
        }
        pub fn getMatrix(self: *const Context) *const Mat4 {
            return self.back();
        }
        pub fn pushMatrix(self: *Context, _mat4: *const Mat4) void {
            self.push_back(_mat4);
        }
        // syntax errors:
        // pub fn popMatrix(self: *Context) void {
        // _ = (((!!(self.size() > @as(U32, @intCast(1)))) or (((_assert(&"\"m_matrixStack.size() > 1\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(658))); 0)) != 0)));
        // ;
        // self.pop_back();
        // }
        //
        pub fn setId(self: *Context, _id: Id) void {
            self.back().* = _id;
        }
        pub fn getId(self: *const Context) Id {
            return self.back();
        }
        pub fn pushId(self: *Context, _id: Id) void {
            self.push_back(_id);
        }
        // syntax errors:
        // pub fn popId(self: *Context) void {
        // _ = (((!!(self.size() > @as(U32, @intCast(1)))) or (((_assert(&"\"m_idStack.size() > 1\"", &"\"C:\\\\Projects\\\\elvengroin-legacy\\\\external\\\\im3d\\\\im3d.h\"", @as(c_uint, @intCast(663))); 0)) != 0)));
        // ;
        // self.pop_back();
        // }
        //
        pub fn getAppData(self: *Context) *AppData {
            return self.m_appData;
        }
        extern fn _1_Im3d_Context_gizmoAxisTranslation_Behavior_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _snap: f32, _worldHeight: f32, _worldSize: f32, _out_: [*c]Vec3) bool;
        /// Low-level interface for internal and app-defined gizmos. May be subject to breaking changes.
        pub const gizmoAxisTranslation_Behavior = _1_Im3d_Context_gizmoAxisTranslation_Behavior_;

        extern fn _1_Im3d_Context_gizmoAxisTranslation_Draw_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _worldHeight: f32, _worldSize: f32, _color: Color) void;
        pub const gizmoAxisTranslation_Draw = _1_Im3d_Context_gizmoAxisTranslation_Draw_;

        extern fn _1_Im3d_Context_gizmoPlaneTranslation_Behavior_(self: *Context, _id: Id, _origin: *const Vec3, _normal: *const Vec3, _snap: f32, _worldSize: f32, _out_: [*c]Vec3) bool;
        pub const gizmoPlaneTranslation_Behavior = _1_Im3d_Context_gizmoPlaneTranslation_Behavior_;

        extern fn _1_Im3d_Context_gizmoPlaneTranslation_Draw_(self: *Context, _id: Id, _origin: *const Vec3, _normal: *const Vec3, _worldSize: f32, _color: Color) void;
        pub const gizmoPlaneTranslation_Draw = _1_Im3d_Context_gizmoPlaneTranslation_Draw_;

        extern fn _1_Im3d_Context_gizmoAxislAngle_Behavior_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _snap: f32, _worldRadius: f32, _worldSize: f32, _out_: [*c]f32) bool;
        pub const gizmoAxislAngle_Behavior = _1_Im3d_Context_gizmoAxislAngle_Behavior_;

        extern fn _1_Im3d_Context_gizmoAxislAngle_Draw_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _worldRadius: f32, _angle: f32, _color: Color, _minAlpha: f32) void;
        pub const gizmoAxislAngle_Draw = _1_Im3d_Context_gizmoAxislAngle_Draw_;

        extern fn _1_Im3d_Context_gizmoAxisScale_Behavior_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _snap: f32, _worldHeight: f32, _worldSize: f32, _out_: [*c]f32) bool;
        pub const gizmoAxisScale_Behavior = _1_Im3d_Context_gizmoAxisScale_Behavior_;

        extern fn _1_Im3d_Context_gizmoAxisScale_Draw_(self: *Context, _id: Id, _origin: *const Vec3, _axis: *const Vec3, _worldHeight: f32, _worldSize: f32, _color: Color) void;
        pub const gizmoAxisScale_Draw = _1_Im3d_Context_gizmoAxisScale_Draw_;

        extern fn _1_Im3d_Context_pixelsToWorldSize_(self: *Context, _position: *const Vec3, _pixels: f32) f32;
        /// Convert pixels -> world space size based on distance between _position and view origin.
        pub const pixelsToWorldSize = _1_Im3d_Context_pixelsToWorldSize_;

        extern fn _1_Im3d_Context_worldSizeToPixels_(self: *Context, _position: *const Vec3, _pixels: f32) f32;
        /// Convert world space size -> pixels based on distance between _position and view origin.
        pub const worldSizeToPixels = _1_Im3d_Context_worldSizeToPixels_;

        extern fn _1_Im3d_Context_estimateLevelOfDetail_(self: *Context, _position: *const Vec3, _worldSize: f32, _min: c_int, _max: c_int) c_int;
        /// Blend between _min and _max based on distance betwen _position and view origin.
        pub fn estimateLevelOfDetail(
            self: *Context,
            _position: *const Vec3,
            _worldSize: f32,
            __opt: struct {
                _min: c_int = 4,
                _max: c_int = 256,
            },
        ) c_int {
            return _1_Im3d_Context_estimateLevelOfDetail_(self, _position, _worldSize, __opt._min, __opt._max);
        }

        extern fn _1_Im3d_Context_makeHot_(self: *Context, _id: Id, _depth: f32, _intersects: bool) bool;
        /// Make _id hot if _depth
        ///<
        /// m_hotDepth
        ///&
        ///&
        /// _intersects.
        pub const makeHot = _1_Im3d_Context_makeHot_;

        extern fn _1_Im3d_Context_makeActive_(self: *Context, _id: Id) void;
        /// Make _id active.
        pub const makeActive = _1_Im3d_Context_makeActive_;

        extern fn _1_Im3d_Context_resetId_(self: *Context) void;
        /// Reset the acive/hot ids and the hot depth.
        pub const resetId = _1_Im3d_Context_resetId_;

        extern fn _1_Im3d_Context_isKeyDown_(self: *const Context, _key: Key) bool;
        /// Interpret key state.
        pub const isKeyDown = _1_Im3d_Context_isKeyDown_;

        pub fn wasKeyPressed(self: *const Context, _key: Key) bool {
            return &self.m_keyDownCurr[_key] and !&self.m_keyDownPrev[_key];
        }
        extern fn _1_Im3d_Context_isVisible_(self: *Context, _vdata: [*c]const VertexData, _prim: DrawPrimitiveType) bool;
        /// Visibiity tests for culling.
        pub const isVisible = _1_Im3d_Context_isVisible_;

        extern fn _2_Im3d_Context_isVisible_(self: *Context, _origin: *const Vec3, _radius: f32) bool;
        pub const isVisible__Overload2 = _2_Im3d_Context_isVisible_;

        extern fn _3_Im3d_Context_isVisible_(self: *Context, _min: *const Vec3, _max: *const Vec3) bool;
        pub const isVisible__Overload3 = _3_Im3d_Context_isVisible_;

        extern fn _1_Im3d_Context_getPrimitiveCount_(self: *const Context, _type: DrawPrimitiveType) U32;
        /// Return the total number of primitives (sorted + unsorted) of the given _type in all layers.
        pub const getPrimitiveCount = _1_Im3d_Context_getPrimitiveCount_;

        extern fn _1_Im3d_Context_getTextCount_(self: *const Context) U32;
        /// Return the total number of text primitives in all layers.
        pub const getTextCount = _1_Im3d_Context_getTextCount_;

        extern fn _1_Im3d_Context_getLayerCount_(self: *const Context) U32;
        /// Return the number of layers.
        pub const getLayerCount = _1_Im3d_Context_getLayerCount_;
    };

    pub const internal = struct {
        extern var _1_Im3d_internal_g_CurrentContext_: *[*c]Context;
        pub const g_CurrentContext = _1_Im3d_internal_g_CurrentContext_;
    };

    pub inline fn GetAppData__Overload2() *AppData {
        return GetContext().getAppData();
    }
    pub inline fn NewFrame__Overload2() void {
        GetContext().reset();
    }
    pub inline fn EndFrame__Overload2() void {
        GetContext().endFrame();
    }
    pub inline fn Draw__Overload2() void {
        GetContext().draw();
    }
    pub inline fn GetDrawLists__Overload2() [*c]const DrawList {
        return GetContext().getDrawLists();
    }
    pub inline fn GetDrawListCount__Overload2() U32 {
        return GetContext().getDrawListCount();
    }
    pub inline fn GetTextDrawLists__Overload2() [*c]const TextDrawList {
        return GetContext().getTextDrawLists();
    }
    pub inline fn GetTextDrawListCount__Overload2() U32 {
        return GetContext().getTextDrawListCount();
    }
    // syntax errors:
    // pub inline fn BeginPoints__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_Points.bits);
    // }
    //
    // syntax errors:
    // pub inline fn BeginLines__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_Lines.bits);
    // }
    //
    // syntax errors:
    // pub inline fn BeginLineLoop__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_LineLoop.bits);
    // }
    //
    // syntax errors:
    // pub inline fn BeginLineStrip__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_LineStrip.bits);
    // }
    //
    // syntax errors:
    // pub inline fn BeginTriangles__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_Triangles.bits);
    // }
    //
    // syntax errors:
    // pub inline fn BeginTriangleStrip__Overload2() void {
    // self.begin(Im3d::PrimitiveMode.PrimitiveMode_TriangleStrip.bits);
    // }
    //
    pub inline fn End__Overload2() void {
        GetContext().end();
    }
    pub inline fn imVertex__Overload9(_position: *const Vec3) void {
        GetContext().vertex(_position, GetContext().getSize(), GetContext().getColor());
    }
    pub inline fn imVertex__Overload2(_position: *const Vec3, _color: Color) void {
        _ = _color; // autofix
        GetContext().vertex(
            _position,
            GetContext().getSize(),
        );
    }
    pub inline fn imVertex__Overload3(_position: *const Vec3, _size: f32) void {
        GetContext().vertex(_position, _size, GetContext().getColor());
    }
    pub inline fn imVertex__Overload4(_position: *const Vec3, _size: f32, _color: Color) void {
        _ = _color; // autofix
        GetContext().vertex(
            _position,
            _size,
        );
    }
    pub inline fn imVertex__Overload5(_x: f32, _y: f32, _z: f32) void {
        Vertex(Vec3.init(_x, _y, _z));
    }
    pub inline fn imVertex__Overload6(_x: f32, _y: f32, _z: f32, _color: Color) void {
        _ = _color; // autofix
        Vertex(
            Vec3.init(_x, _y, _z),
        );
    }
    pub inline fn imVertex__Overload7(_x: f32, _y: f32, _z: f32, _size: f32) void {
        Vertex(Vec3.init(_x, _y, _z), _size);
    }
    pub inline fn imVertex__Overload8(_x: f32, _y: f32, _z: f32, _size: f32, _color: Color) void {
        _ = _color; // autofix
        Vertex(
            Vec3.init(_x, _y, _z),
            _size,
        );
    }
    pub inline fn imPushDrawState__Overload2() void {
        var ctx: *Context = GetContext();
        ctx.pushColor(ctx.getColor());
        ctx.pushAlpha(ctx.getAlpha());
        ctx.pushSize(ctx.getSize());
        ctx.pushEnableSorting(ctx.getEnableSorting());
    }
    pub inline fn imPopDrawState__Overload2() void {
        var ctx: *Context = GetContext();
        ctx.popColor();
        ctx.popAlpha();
        ctx.popSize();
        ctx.popEnableSorting();
    }
    pub inline fn imPushColor__Overload3() void {
        GetContext().pushColor(GetContext().getColor());
    }
    pub inline fn imPushColor__Overload2(_color: Color) void {
        _ = _color; // autofix
        GetContext().pushColor();
    }
    pub inline fn imPopColor__Overload2() void {
        GetContext().popColor();
    }
    pub inline fn imSetColor__Overload3(_color: Color) void {
        _ = _color; // autofix
        GetContext().setColor();
    }
    pub inline fn imSetColor__Overload2(_r: f32, _g: f32, _b: f32, _a: f32) void {
        GetContext().setColor(Color.init(_r, _g, _b, _a));
    }
    pub inline fn imGetColor__Overload2() Color {
        return GetContext().getColor();
    }
    pub inline fn imPushAlpha__Overload3() void {
        GetContext().pushAlpha(GetContext().getAlpha());
    }
    pub inline fn imPushAlpha__Overload2(_alpha: f32) void {
        GetContext().pushAlpha(_alpha);
    }
    pub inline fn imPopAlpha__Overload2() void {
        GetContext().popAlpha();
    }
    pub inline fn imSetAlpha__Overload2(_alpha: f32) void {
        GetContext().setAlpha(_alpha);
    }
    pub inline fn imGetAlpha__Overload2() f32 {
        return GetContext().getAlpha();
    }
    pub inline fn imPushSize__Overload3() void {
        GetContext().pushSize(GetContext().getAlpha());
    }
    pub inline fn imPushSize__Overload2(_size: f32) void {
        GetContext().pushSize(_size);
    }
    pub inline fn imPopSize__Overload2() void {
        GetContext().popSize();
    }
    pub inline fn imSetSize__Overload2(_size: f32) void {
        GetContext().setSize(_size);
    }
    pub inline fn imGetSize__Overload2() f32 {
        return GetContext().getSize();
    }
    pub inline fn imPushEnableSorting__Overload3() void {
        GetContext().pushEnableSorting(GetContext().getEnableSorting());
    }
    pub inline fn imPushEnableSorting__Overload2(_enable: bool) void {
        GetContext().pushEnableSorting(_enable);
    }
    pub inline fn imPopEnableSorting__Overload2() void {
        GetContext().popEnableSorting();
    }
    pub inline fn imEnableSorting__Overload2(_enable: bool) void {
        GetContext().setEnableSorting(_enable);
    }
    pub inline fn imPushMatrix__Overload3() void {
        GetContext().pushMatrix(GetContext().getMatrix());
    }
    pub inline fn imPushMatrix__Overload2(_mat4: *const Mat4) void {
        GetContext().pushMatrix(_mat4);
    }
    pub inline fn imPopMatrix__Overload2() void {
        GetContext().popMatrix();
    }
    pub inline fn imSetMatrix__Overload2(_mat4: *const Mat4) void {
        GetContext().setMatrix(_mat4);
    }
    pub inline fn imSetIdentity__Overload2() void {
        GetContext().setMatrix();
    }
    pub inline fn imPushId__Overload6() void {
        GetContext().pushId(GetContext().getId());
    }
    pub inline fn imPushId__Overload2(_id: Id) void {
        GetContext().pushId(_id);
    }
    pub inline fn imPushId__Overload3(_str: [*c]const u8) void {
        GetContext().pushId(MakeId(_str));
    }
    pub inline fn imPushId__Overload4(_ptr: ?*const anyopaque) void {
        GetContext().pushId(MakeId(_ptr));
    }
    pub inline fn imPushId__Overload5(_i: c_int) void {
        GetContext().pushId(MakeId(_i));
    }
    pub inline fn imPopId__Overload2() void {
        GetContext().popId();
    }
    pub inline fn imGetId__Overload2() Id {
        return GetContext().getId();
    }
    pub inline fn imPushLayerId__Overload3() void {
        GetContext().pushLayerId(GetContext().getLayerId());
    }
    pub inline fn imPushLayerId__Overload4(_layer: Id) void {
        GetContext().pushLayerId(_layer);
    }
    pub inline fn imPushLayerId__Overload2(_str: [*c]const u8) void {
        PushLayerId(MakeId(_str));
    }
    pub inline fn imPopLayerId__Overload2() void {
        GetContext().popLayerId();
    }
    pub inline fn imGetLayerId__Overload2() Id {
        return GetContext().getLayerId();
    }
    pub inline fn imGizmoTranslation__Overload3(_id: [*c]const u8, _translation_: [*c]f32, _local: bool) bool {
        return GizmoTranslation(MakeId(_id), _translation_, _local);
    }
    pub inline fn imGizmoRotation__Overload3(_id: [*c]const u8, _rotation_: [*c]f32, _local: bool) bool {
        return GizmoRotation(MakeId(_id), _rotation_, _local);
    }
    pub inline fn imGizmoScale__Overload3(_id: [*c]const u8, _scale_: [*c]f32) bool {
        return GizmoScale(MakeId(_id), _scale_);
    }
    pub inline fn imGizmo__Overload5(_id: [*c]const u8, _translation_: [*c]f32, _rotation_: [*c]f32, _scale_: [*c]f32) bool {
        return Gizmo(MakeId(_id), _translation_, _rotation_, _scale_);
    }
    pub inline fn imGizmo__Overload2(_id: [*c]const u8, _transform_: [*c]f32) bool {
        return Gizmo(MakeId(_id), _transform_);
    }
    pub inline fn imGetActiveId__Overload2() Id {
        return GetContext().m_appActiveId;
    }
    pub inline fn imGetHotId__Overload2() Id {
        return GetContext().m_appHotId;
    }
    pub inline fn imIsVisible__Overload3(_origin: *const Vec3, _radius: f32) bool {
        return GetContext().isVisible(_origin, _radius);
    }
    pub inline fn imIsVisible__Overload2(_min: *const Vec3, _max: *const Vec3) bool {
        return GetContext().isVisible(_min, _max);
    }
    pub inline fn imGetContext__Overload2() *Context {
        return internal.g_CurrentContext.*;
    }
    pub inline fn imSetContext__Overload2(_ctx: *Context) void {
        internal.g_CurrentContext = &_ctx;
    }
    pub inline fn imMergeContexts__Overload2(_dst_: *Context, _src: *const Context) void {
        _ = _dst_; // autofix
        GetContext().merge(_src);
    }
};
